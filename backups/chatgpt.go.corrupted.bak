package chatgpt

import (
	"context"
	"fmt"
	"log"
	"regexp"
	"strings"
	"time"

	"github.com/chromedp/chromedp"
)

// ChatGPT represents a ChatGPT session
type ChatGPT struct {
	Ctx    context.Context // Exported for CLI access
	// Note: We've already attempted to submit. Do not retry clicking here to avoid blocking
	// when stop button replaces the send button.
		chromedp.Evaluate(`(function(){
			const ce = document.querySelector('#prompt-textarea');
			if (!ce) return false;
			ce.focus();
			const sel = window.getSelection();
			const range = document.createRange();
			range.selectNodeContents(ce);
			sel.removeAllRanges();
			sel.addRange(range);
			document.execCommand('delete');
			return true;
		})();`, nil),
		// Type the message
		chromedp.SendKeys(InputElement, message, chromedp.ByQuery),
	)
	if typeErr != nil {
		// Fallback to execCommand insertion
		_ = chromedp.Run(c.Ctx, chromedp.Evaluate(fmt.Sprintf(`
			(function(msg){
				const ce = document.querySelector('#prompt-textarea');
				if (!ce) return false;
				ce.focus();
				ce.innerHTML = '';
				document.execCommand('insertText', false, msg);
				ce.dispatchEvent(new InputEvent('input', {bubbles:true}));
				return true;
			})(%q);
		`, message), nil))
	} else {
		// Dispatch an input event to ensure send button enables
		_ = chromedp.Run(c.Ctx, chromedp.Evaluate(`
			(function(){
				const ce = document.querySelector('#prompt-textarea');
				if (ce) ce.dispatchEvent(new InputEvent('input', {bubbles:true}));
			})();
		`, nil))
	}

	// Wait up to a few seconds until send button is enabled
	{
		deadline := time.Now().Add(5 * time.Second)
		for time.Now().Before(deadline) {
			var enabled bool
			_ = chromedp.Run(c.Ctx, chromedp.Evaluate(`
				(function(){
					const btn = document.querySelector('button[data-testid="send-button"]') || document.querySelector('#composer-submit-button');
					if (!btn) return false;
					return !btn.disabled && btn.getAttribute('aria-disabled') !== 'true' && btn.offsetParent !== null;
				})();
			`, &enabled))
			if enabled { break }
			time.Sleep(150 * time.Millisecond)
		}
	}

	// Ensure send button becomes enabled after typing (like Selenium EC.element_to_be_clickable)
	var sendReady bool
	_ = chromedp.Run(c.Ctx, chromedp.Evaluate(`
		(function(){
			const btn = document.querySelector('button[data-testid="send-button"]') || document.querySelector('#composer-submit-button');
			if (!btn) return false;
			const enabled = !btn.disabled && btn.offsetParent !== null && getComputedStyle(btn).pointerEvents !== 'none';
			return enabled;
		})();
	`, &sendReady))

	// Submit: try click send button, else send Enter
	clickErr := chromedp.Run(c.Ctx,
		chromedp.WaitVisible(SubmitButton, chromedp.ByQuery),
		chromedp.ScrollIntoView(SubmitButton, chromedp.ByQuery),
		chromedp.Click(SubmitButton, chromedp.ByQuery),
	)
	if clickErr != nil {
		log.Printf("‚ö†Ô∏è Click submit failed, trying JS click fallbacks then Enter: %v", clickErr)
		// Try JS click fallback and alternate selectors
		_ = chromedp.Run(c.Ctx, chromedp.Evaluate(`
			(function(){
				const candidates = [
					document.querySelector('button[data-testid="send-button"]'),
					document.querySelector('#composer-submit-button'),
					document.querySelector('button[type="submit"]'),
				].filter(Boolean);
				for (const el of candidates){
					try { el.scrollIntoView({block:'center'}); el.click(); return true; } catch(e){}
				}
				return false;
			})();
		`, nil))
		// Fallback to Enter key if still not submitted
		_ = chromedp.Run(c.Ctx, chromedp.SendKeys(InputElement, "\n", chromedp.ByQuery))
	}

	log.Println("‚úÖ Message submitted, waiting for response...")

	// Debug submit button
	log.Println("üîç DEBUG: Checking submit button...")
	var submitInfo map[string]interface{}
	err = chromedp.Run(c.Ctx, chromedp.Evaluate(`
		(function() {
			const submit1 = document.querySelector('button[data-testid="send-button"]');
			const submit2 = document.querySelector('#composer-submit-button');
			const submit3 = document.querySelector('button[type="submit"]');
			const submit4 = document.querySelector('[data-testid="send-button"]');
			
			console.log('Submit1 (Python-style):', submit1);
			console.log('Submit2 (Legacy):', submit2);
			console.log('Submit3 (Type submit):', submit3);
			console.log('Submit4 (Data testid):', submit4);
			
			const button = submit1 || submit2 || submit3 || submit4;
			if (button) {
				return {
					exists: true,
					visible: button.offsetParent !== null,
					enabled: !button.disabled,
					tagName: button.tagName,
					className: button.className,
					testId: button.getAttribute('data-testid'),
					type: button.type,
					text: button.textContent || button.innerText
				};
			}
			return {exists: false};
		})();
	`, &submitInfo))
	
	log.Printf("üîç DEBUG: Submit button info: %+v", submitInfo)

	// Click submit button using Python-style
	log.Println("üöÄ Trying to click send button...")
	err = chromedp.Run(c.Ctx,
		chromedp.WaitVisible(SubmitButton, chromedp.ByQuery),
		chromedp.Click(SubmitButton, chromedp.ByQuery),
	)
	if err != nil {
		log.Printf("üîç DEBUG: Python-style submit failed: %v", err)
		// Try multiple fallback selectors
		selectors := []string{
			"#composer-submit-button",
			"button[type='submit']",
			"[data-testid='send-button']",
			"button:has(svg)",
		}
		
		for _, selector := range selectors {
			log.Printf("üîç DEBUG: Trying selector: %s", selector)
			err = chromedp.Run(c.Ctx,
				chromedp.Click(selector, chromedp.ByQuery),
			)
			if err == nil {
				log.Printf("‚úÖ Success with selector: %s", selector)
				break
			}
			log.Printf("‚ùå Failed with selector: %s - %v", selector, err)
		}
		
		if err != nil {
			return "", fmt.Errorf("failed to click send button with all selectors: %v", err)
		}
	}
	
	log.Println("‚úÖ Send button clicked successfully")

	log.Println("‚è≥ Waiting for response...")

	// Wait for Stop Button appear/disappear to mark generation window
	log.Println("üîÑ Waiting for stop button to appear...")
	
	// Wait for stop button to appear (ChatGPT is generating)
	err = chromedp.Run(c.Ctx, chromedp.WaitVisible(StopButton, chromedp.ByQuery))
	if err != nil {
		// Fallback to XPath
		err = chromedp.Run(c.Ctx, chromedp.WaitVisible(StopXPath, chromedp.BySearch))
		if err != nil {
			log.Printf("‚ö†Ô∏è Stop button not detected, continuing anyway: %v", err)
		}
	} else {
		log.Println("‚úÖ Stop button appeared - ChatGPT is generating...")
	}
	
	// Wait for stop button to disappear (ChatGPT finished)
	log.Println("‚è≥ Waiting for stop button to disappear...")
	// Use a bounded wait loop to mimic Selenium's WebDriverWait with timeout
	{
		done := false
		deadline := time.Now().Add(60 * time.Second)
		for time.Now().Before(deadline) {
			var visible bool
			_ = chromedp.Run(c.Ctx, chromedp.Evaluate(`
				(function(){
					const el = document.querySelector('button[data-testid="stop-button"]');
					return !!(el && el.offsetParent !== null);
				})();
			`, &visible))
			if !visible {
				done = true
				break
			}
			time.Sleep(300 * time.Millisecond)
		}
		if done {
			log.Println("‚úÖ Stop button disappeared - ChatGPT finished!")
		} else {
			log.Println("‚ö†Ô∏è Stop button may still be present after timeout, continuing‚Ä¶")
		}
	}
	
	// Wait a bit more like Python version
	time.Sleep(2 * time.Second)
	
	// SIMPLE RESPONSE EXTRACTION like Python version
	var response string
	
	// PYTHON-STYLE: Simple response extraction using reliable selector
	log.Println("üì• Extracting response using simple selector...")
	
	// Get all assistant responses and take the latest one (like Python)
	var allResponses []string
	err = chromedp.Run(c.Ctx, chromedp.Evaluate(`
		(function() {
			const responses = document.querySelectorAll('div[data-message-author-role="assistant"]');
			const results = [];
			for (let i = 0; i < responses.length; i++) {
				const text = responses[i].textContent || responses[i].innerText || '';
				if (text.trim()) {
					results.push(text.trim());
				}
			}
			return results;
		})();
	`, &allResponses))
	
	if err == nil && len(allResponses) > 0 {
		// Get the latest response (like Python version)
		response = allResponses[len(allResponses)-1]
		log.Printf("‚úÖ Got response using simple approach: %d chars", len(response))
		// If response is just the screen-reader prefix or too short, try a deeper extraction
		if strings.TrimSpace(response) == "ChatGPT said:" || len(strings.TrimSpace(response)) < 4 {
			log.Println("‚ÑπÔ∏è Response was prefix-only, trying markdown extraction...")
			var deep string
			_ = chromedp.Run(c.Ctx, chromedp.Evaluate(`
				(function(){
					const containers = Array.from(document.querySelectorAll('div[data-message-author-role="assistant"]'));
					for (let i = containers.length - 1; i >= 0; i--) {
						const c = containers[i];
						const md = c.querySelector('div.markdown, div[class*="prose"], [data-message-content]');
						if (md) {
							const t = (md.textContent || md.innerText || '').trim();
							if (t) return t;
						}
						const t2 = (c.textContent || c.innerText || '').trim();
						if (t2) return t2;
					}
					return '';
				})();
			`, &deep))
			if strings.TrimSpace(deep) != "" {
				response = deep
			}
		}
	} else {
		log.Printf("‚ö†Ô∏è Simple approach failed: %v", err)
	}
	
	// If Python approach got response, clean and return it
	if response != "" {
		// Clean the response like Python version
		response = strings.TrimSpace(response)
		
		// Remove common prefixes
		if strings.HasPrefix(response, "ChatGPT said:") {
			response = strings.TrimSpace(strings.TrimPrefix(response, "ChatGPT said:"))
		}
		
		// Remove artifacts
		response = strings.ReplaceAll(response, "Copy code", "")
		response = strings.ReplaceAll(response, "Always show details", "")
		response = strings.ReplaceAll(response, "Show more", "")
		response = strings.ReplaceAll(response, "Show less", "")
		
		// Final cleanup
		response = strings.TrimSpace(response)
		
		log.Printf("‚úÖ Python-style extraction successful: %d chars", len(response))
		
		// Call onUpdate if provided
		if onUpdate != nil {
			onUpdate(response, true) // Mark as complete
		}
		
		return response, nil
	}
	
	// Extra fallback: try "Copy" turn button like Python's pyperclip path
	if strings.TrimSpace(response) == "" {
		var copied string
		_ = chromedp.Run(c.Ctx, chromedp.Evaluate(`
			(async function(){
				try {
					// find latest assistant article, then its copy button
					const articles = Array.from(document.querySelectorAll('article')).filter(a => a.getAttribute('data-turn')==='assistant' || a.querySelector('[data-message-author-role="assistant"]'));
					const last = articles[articles.length-1];
					if (!last) return '';
					const btn = last.querySelector('[data-testid="copy-turn-action-button"]');
					if (!btn) return '';
					btn.click();
					// wait a tick for clipboard write
					await new Promise(r=>setTimeout(r, 200));
					// try to read from the DOM clipboard shim when permissions block navigator.clipboard
					const md = last.querySelector('div.markdown, div[class*="prose"], [data-message-content]');
					const text = (md ? (md.textContent||md.innerText) : (last.textContent||last.innerText))||'';
					return text.trim();
				} catch(e){ return ''; }
			})();
		`, &copied))
		if strings.TrimSpace(copied) != "" {
			response = copied
		}
	}

	// Fallback to complex approach if Python style failed
	log.Println("‚ö†Ô∏è Falling back to complex extraction...")
	
	// Setup instant MutationObserver
	observerScript := `
		(function() {
			let lastResponse = '';
			let stableCount = 0;
			
			function getCurrentResponse() {
				// More robust extraction targeting actual ChatGPT response structure
				const articles = document.querySelectorAll('article');
				for (let i = articles.length - 1; i >= 0; i--) {
					const article = articles[i];
					if (article.getAttribute('data-turn') === 'assistant' || 
						article.textContent.includes('ChatGPT said:') ||
						article.querySelector('[data-message-author-role="assistant"]')) {
						
						let text = '';
						
						// Strategy 1: Look for code blocks first (for programming responses)
						const codeBlocks = article.querySelectorAll('pre code, code pre, .hljs');
						if (codeBlocks.length > 0) {
							let codeText = '';
							codeBlocks.forEach(block => {
								// Get text from syntax-highlighted code
								const spans = block.querySelectorAll('span');
								if (spans.length > 0) {
									spans.forEach(span => {
										codeText += span.textContent || span.innerText || '';
									});
								} else {
									codeText += block.textContent || block.innerText || '';
								}
								codeText += '\n';
							});
							if (codeText.trim()) {
								text = codeText.trim();
							}
						}
						
						// Strategy 2: Try markdown/prose content
						if (!text) {
							const contentDivs = article.querySelectorAll('div[class*="markdown"], div[class*="prose"], div[data-message-content]');
							for (const div of contentDivs) {
								const divText = div.textContent || div.innerText || '';
								if (divText.length > text.length) {
									text = divText;
								}
							}
						}
						
						// Strategy 3: Get all text but filter out UI elements
						if (!text) {
							text = article.textContent || article.innerText || '';
							// Remove common UI text that gets mixed in
							text = text.replace(/Copy code/g, '');
							text = text.replace(/Always show details/g, '');
							text = text.replace(/Show more/g, '');
							text = text.replace(/Show less/g, '');
						}
						
						// Clean but preserve structure
						if (text.includes('{') || text.includes('def ') || text.includes('#include') || text.includes('import ')) {
							// Preserve code/JSON formatting
							text = text.replace(/\n\s*\n\s*\n/g, '\n\n').trim();
						} else {
							// Regular text - normalize spaces
							text = text.replace(/\s+/g, ' ').trim();
						}
						
						return text;
					}
				}
				return '';
			}
			
			function processResponse() {
				const currentResponse = getCurrentResponse();
				
				// Skip thinking/loading messages
				if (!currentResponse || 
					currentResponse.includes('Thinking longer for a better answer') ||
					currentResponse.includes('Get a quick answer') ||
					currentResponse.includes('ChatGPT is thinking') ||
					currentResponse.length < 20) {
					return;
				}
				
				// Clean response more thoroughly
				let cleanResponse = currentResponse.trim();
				
				// Remove common prefixes and artifacts
				if (cleanResponse.startsWith('ChatGPT said:')) {
					cleanResponse = cleanResponse.replace('ChatGPT said:', '').trim();
				}
				if (cleanResponse.startsWith('jsonCopyEdit')) {
					cleanResponse = cleanResponse.replace(/^jsonCopyEdit\s*/, '').trim();
				}
				if (cleanResponse.startsWith('pythonCopyEdit')) {
					cleanResponse = cleanResponse.replace(/^pythonCopyEdit\s*/, '').trim();
				}
				if (cleanResponse.startsWith('pythonAlways show details')) {
					cleanResponse = cleanResponse.replace(/^pythonAlways show details\s*/, '').trim();
				}
				if (cleanResponse.startsWith('Copy')) {
					cleanResponse = cleanResponse.replace(/^Copy\s*/, '').trim();
				}
				if (cleanResponse.startsWith('Generating')) {
					cleanResponse = cleanResponse.replace(/^Generating[^}]*}?\s*/, '').trim();
				}
				if (cleanResponse.startsWith('Get a quick answer')) {
					return; // Skip this completely
				}
				if (cleanResponse.startsWith('Analyzed')) {
					cleanResponse = cleanResponse.replace(/^Analyzed\s*/, '').trim();
				}
				
				// Process any meaningful content (lower threshold so short texts like 'test' pass)
				if (cleanResponse && cleanResponse.length > 3 && cleanResponse !== lastResponse) {
					// NEW TEXT DETECTED - INSTANT UPDATE!
					window.chatgptStream.updates.push({
						text: cleanResponse,
						complete: false,
						timestamp: Date.now()
					});
					lastResponse = cleanResponse;
					stableCount = 0;
				} else if (cleanResponse && cleanResponse === lastResponse && cleanResponse.length > 3) {
					// Text stable - check if complete (INCREASED for long responses)
					stableCount++;
					// For very long responses (ChatGPT-5 can give up to 6000 words!), wait much longer
					let requiredStableCount = 3; // default - ok for short responses
					if (cleanResponse.length > 10000) requiredStableCount = 15; // Very long responses
					else if (cleanResponse.length > 5000) requiredStableCount = 12;
					else if (cleanResponse.length > 2000) requiredStableCount = 10;
					else if (cleanResponse.length > 1000) requiredStableCount = 8;
					else if (cleanResponse.length > 500) requiredStableCount = 6;
					else if (cleanResponse.length > 200) requiredStableCount = 4;
					
					if (stableCount >= requiredStableCount) {
						window.chatgptStream.updates.push({
							text: cleanResponse,
							complete: true,
							timestamp: Date.now()
						});
						window.chatgptStream.isComplete = true;
						if (window.chatgptStream.observer) {
							window.chatgptStream.observer.disconnect();
						}
					}
				}
			}
			
			// Setup MutationObserver for INSTANT detection
			const observer = new MutationObserver(() => {
				processResponse(); // Immediate processing on ANY DOM change
			});
			
			window.chatgptStream.observer = observer;
			
			// Observe with maximum sensitivity
			const threadContainer = document.querySelector('#thread') || document.body;
			observer.observe(threadContainer, {
				childList: true,
				subtree: true,
				characterData: true,
				attributes: true,
				attributeOldValue: true,
				characterDataOldValue: true
			});
			
			// Ultra-fast fallback polling (100ms)
			const interval = setInterval(processResponse, 100);
			
			// Cleanup after timeout
			setTimeout(() => {
				observer.disconnect();
				clearInterval(interval);
				window.chatgptStream.isComplete = true;
			}, 60000);
			
			// Initial check
			processResponse();
		})();
	`
	
	// Execute observer setup
	err = chromedp.Run(c.Ctx, chromedp.Evaluate(observerScript, nil))
	if err != nil {
		return "", fmt.Errorf("failed to setup observer: %v", err)
	}
	
	// Ultra-fast polling for updates (50ms for maximum responsiveness)
	maxWait := 60 * 20 // 60 seconds with 50ms intervals
	for i := 0; i < maxWait; i++ {
		time.Sleep(50 * time.Millisecond)
		
		// Check for new updates
		var streamData map[string]interface{}
		err = chromedp.Run(c.Ctx, chromedp.Evaluate(`window.chatgptStream`, &streamData))
		if err != nil {
			continue
		}
		
		if updates, ok := streamData["updates"].([]interface{}); ok && len(updates) > 0 {
			// Process all pending updates
			for _, update := range updates {
				if updateMap, ok := update.(map[string]interface{}); ok {
					if text, ok := updateMap["text"].(string); ok {
						if complete, ok := updateMap["complete"].(bool); ok {
							if onUpdate != nil {
								onUpdate(text, complete)
							}
							response = text
							if complete {
								// Clear updates and return
								chromedp.Run(c.Ctx, chromedp.Evaluate(`window.chatgptStream.updates = []`, nil))
								goto cleanup
							}
						}
					}
				}
			}
			// Clear processed updates
			chromedp.Run(c.Ctx, chromedp.Evaluate(`window.chatgptStream.updates = []`, nil))
		}
		
		// Check if complete
		if isComplete, ok := streamData["isComplete"].(bool); ok && isComplete {
			break
		}
	}
	
	cleanup:
	// Cleanup observer
	chromedp.Run(c.Ctx, chromedp.Evaluate(`
		if (window.chatgptStream && window.chatgptStream.observer) {
			window.chatgptStream.observer.disconnect();
		}
		delete window.chatgptStream;
	`, nil))

	// Extract the final response with comprehensive cleaning
	if response == "" {
		err = chromedp.Run(c.Ctx, chromedp.Evaluate(`
			(function() {
				const articles = document.querySelectorAll('article');
				for (let i = articles.length - 1; i >= 0; i--) {
					const article = articles[i];
					if (article.getAttribute('data-turn') === 'assistant' || 
						article.textContent.includes('ChatGPT said:')) {
						
						// Multiple extraction strategies
						let text = '';
						
						// Strategy 1: Try markdown content first
						const markdownDiv = article.querySelector('div[class*="markdown"]');
						if (markdownDiv) {
							text = markdownDiv.textContent || markdownDiv.innerText || '';
						}
						
						// Strategy 2: Try prose content
						if (!text) {
							const proseDiv = article.querySelector('div[class*="prose"]');
							if (proseDiv) {
								text = proseDiv.textContent || proseDiv.innerText || '';
							}
						}
						
						// Strategy 3: Full article text
						if (!text) {
							text = article.textContent || article.innerText || '';
						}
						
						// Clean the text thoroughly
						text = text.trim();
						
						// Remove unwanted prefixes
						text = text.replace(/^ChatGPT said:\s*/, '');
						text = text.replace(/^jsonCopyEdit\s*/, '');
						text = text.replace(/^Generating[^}]*}?\s*/, '');
						text = text.replace(/^Get a quick answer\s*/, '');
						text = text.replace(/^Thought for \d+[ms]\s*/, '');
						
						// Preserve JSON/code structure or normalize spaces
						if (text.includes('{') || text.includes('def ') || text.includes('import ') || text.includes('class ')) {
							// Preserve code formatting
							text = text.replace(/\n\s*\n\s*\n/g, '\n\n').trim();
						} else {
							// Regular text - normalize spaces
							text = text.replace(/\s+/g, ' ').trim();
						}
						
						return text;
					}
				}
				return '';
			})();
		`, &response))
	}

	if err != nil || strings.TrimSpace(response) == "" {
		// Fallback to simple selector
		// Prefer last assistant container markdown
		var deep string
		deepErr := chromedp.Run(c.Ctx, chromedp.Evaluate(`
			(function(){
				const containers = Array.from(document.querySelectorAll('div[data-message-author-role="assistant"]'));
				for (let i = containers.length - 1; i >= 0; i--) {
					const c = containers[i];
					const md = c.querySelector('div.markdown, div[class*="prose"], [data-message-content]');
					if (md) {
						const t = (md.textContent || md.innerText || '').trim();
						if (t) return t;
					}
					const t2 = (c.textContent || c.innerText || '').trim();
					if (t2) return t2;
				}
				return '';
			})();
		`, &deep))
		if deepErr == nil && strings.TrimSpace(deep) != "" {
			response = deep
		} else {
			err = chromedp.Run(c.Ctx,
				chromedp.Text(`article:last-child`, &response, chromedp.ByQuery),
			)
			if err != nil {
				return "", fmt.Errorf("failed to get response: %v", err)
			}
		}
	}

	// Clean up the response
	response = strings.TrimSpace(response)

	// Remove "ChatGPT said:" prefix if present
	if strings.HasPrefix(response, "ChatGPT said:") {
		response = strings.TrimSpace(strings.TrimPrefix(response, "ChatGPT said:"))
	}

	// Remove "Thought for Xs" prefix if present
	thoughtRegex := regexp.MustCompile(`^Thought for \d+s\s*`)
	response = thoughtRegex.ReplaceAllString(response, "")

	// Clean up extra whitespace but preserve structure for code/JSON
	// Don't compress whitespace if it looks like code or JSON
	if !strings.Contains(response, "{") && !strings.Contains(response, "```") {
		response = regexp.MustCompile(`\s+`).ReplaceAllString(response, " ")
	}
	response = strings.TrimSpace(response)

	if response == "" {
		return "", fmt.Errorf("received empty response")
	}

	return response, nil
}

// SendMessage - backward compatibility wrapper
func (c *ChatGPT) SendMessage(message string) (string, error) {
	return c.SendMessageWithStreaming(message, nil)
}

// StartNewChat starts a new chat session
func (c *ChatGPT) StartNewChat() error {
	log.Println("üÜï Starting new chat...")

	err := chromedp.Run(c.Ctx,
		chromedp.Click(NewChatXPath, chromedp.BySearch),
		chromedp.Sleep(2*time.Second), // Wait for new chat to load
	)
	if err != nil {
		return fmt.Errorf("failed to start new chat: %v", err)
	}

	log.Println("‚úÖ New chat started")
	return nil
}

// GetChatHistory gets the list of chat history
func (c *ChatGPT) GetChatHistory() ([]ChatHistoryItem, error) {
	log.Println("üìú Getting chat history...")

	var historyItems []ChatHistoryItem

	// Get all history links
	var nodes []map[string]string
	err := chromedp.Run(c.Ctx,
		chromedp.AttributesAll(`#history a[href^="/c/"]`, &nodes, chromedp.ByQueryAll),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get history nodes: %v", err)
	}

	// Extract information from each history item
	for i, attrs := range nodes {
		if i >= 10 { // Limit to 10 recent chats
			break
		}

		href := attrs["href"]
		var title string
		err = chromedp.Run(c.Ctx,
			chromedp.Text(fmt.Sprintf(`#history a[href="%s"]`, href), &title, chromedp.ByQuery),
		)
		if err != nil {
			log.Printf("Failed to get details for history item %d: %v", i, err)
			continue
		}

		historyItems = append(historyItems, ChatHistoryItem{
			Title: strings.TrimSpace(title),
			URL:   "https://chatgpt.com" + href,
			ID:    extractChatID(href),
		})
	}

	log.Printf("üìú Found %d chat history items", len(historyItems))
	return historyItems, nil
}

// OpenChat opens a specific chat by ID
func (c *ChatGPT) OpenChat(chatID string) error {
	log.Printf("üìÇ Opening chat: %s", chatID)

	url := fmt.Sprintf("https://chatgpt.com/c/%s", chatID)
	err := chromedp.Run(c.Ctx,
		chromedp.Navigate(url),
		chromedp.Sleep(3*time.Second), // Wait for chat to load
	)
	if err != nil {
		return fmt.Errorf("failed to open chat: %v", err)
	}

	log.Println("‚úÖ Chat opened")
	return nil
}

// ChatHistoryItem represents a chat history item
type ChatHistoryItem struct {
	Title string
	URL   string
	ID    string
}

// Helper function to extract chat ID from href
func extractChatID(href string) string {
	parts := strings.Split(href, "/")
	if len(parts) >= 3 && parts[1] == "c" {
		return parts[2]
	}
	return ""
}

// WaitForPageLoad waits for ChatGPT to be ready
func (c *ChatGPT) WaitForPageLoad() error {
	// Just do a simple check - don't be too strict
	err := chromedp.Run(c.Ctx,
		chromedp.Sleep(2*time.Second), // Simple wait
	)
	return err
}
